<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Pancake V3 USDT/USDC — Demo</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.9.0/dist/ethers.min.js"></script>
  <style>
    body{font-family:Inter,system-ui; max-width:920px;margin:22px auto;padding:12px;}
    button{padding:8px 12px;margin:6px;}
    input{padding:6px;margin:6px}
    pre{background:#f6f8fa;padding:12px;border-radius:6px;overflow:auto;}
    .row{display:flex;gap:12px;align-items:center}
  </style>
</head>
<body>
  <h2>Pancake V3 — Pool USDT / USDC (0x92b7...3121)</h2>
  <div id="status">status: desconectado</div>

  <div class="row">
    <button id="connectBtn">Conectar MetaMask (BSC)</button>
    <button id="refreshBtn">Atualizar info da pool</button>
  </div>

  <h3>Pool info</h3>
  <div id="poolInfo"><em>clique em atualizar</em></div>

  <h3>Ações</h3>
  <div>
    <label>Quantidade USDT (ex: 100): <input id="usdtAmount" value="10"/></label>
    <button id="approveUSDT">Aprovar USDT (router)</button>
    <button id="swapHalf">Swap metade USDT → USDC (exemplo)</button>
  </div>

  <h4>Coletar taxas (collect)</h4>
  <div>
    <label>tickLower: <input id="tickLower" value="0"/></label>
    <label>tickUpper: <input id="tickUpper" value="0"/></label>
    <button id="fetchPosition">Buscar posição (tokensOwed)</button>
    <button id="collectFees">Coletar tudo (collect)</button>
  </div>

  <h4>Logs / output</h4>
  <pre id="log"></pre>

<script>
(async()=>{

  // -------- CONFIGURAÇÕES --------
  const POOL_ADDRESS = "0x92b7807bF19b7DDdf89b706143896d05228f3121";
  // PancakeSwap Router / Smart Router na BSC (use Smart Router ou Router V2 conforme preferir)
  const SMART_ROUTER = "0x13f4EA83D0bd40E75C8222255bc855a974568Dd4"; // Pancake v3 smart router (developer page)
  const ROUTER_V2 = "0x10ED43C718714eb63d5aA57B78B54704E256024E"; // PancakeV2 router (comum na BSC)
  const CHAIN_ID = 56; // BSC mainnet

  // Minimal ABI (apenas funções usadas)
  const POOL_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function slot0() view returns (uint160 sqrtPriceX96, int24 tick, uint16 observationIndex, uint16 observationCardinality, uint16 observationCardinalityNext, uint32 feeProtocol, bool unlocked)",
    "function tickSpacing() view returns (int24)",
    "function fee() view returns (uint24)",
    "function mint(address recipient,int24 tickLower,int24 tickUpper,uint128 amount,bytes calldata data) returns (uint256 amount0,uint256 amount1)",
    "function collect(address recipient,uint128 amount0Requested,uint128 amount1Requested) returns (uint128 amount0,uint128 amount1)",
    "function positions(bytes32) view returns (uint128 liquidity,uint256 feeGrowthInside0LastX128,uint256 feeGrowthInside1LastX128,uint128 tokensOwed0,uint128 tokensOwed1)",
    "function observe(uint32[] calldata secondsAgos) view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)"
  ];

  const ERC20_ABI = [
    "function symbol() view returns (string)",
    "function decimals() view returns (uint8)",
    "function balanceOf(address) view returns (uint256)",
    "function approve(address spender,uint256 amount) returns (bool)",
    "function allowance(address owner,address spender) view returns (uint256)"
  ];

  // -------- UI elements ----------
  const connectBtn = document.getElementById("connectBtn");
  const refreshBtn = document.getElementById("refreshBtn");
  const poolInfoDiv = document.getElementById("poolInfo");
  const logEl = document.getElementById("log");
  const approveUSDTBtn = document.getElementById("approveUSDT");
  const swapHalfBtn = document.getElementById("swapHalf");
  const fetchPositionBtn = document.getElementById("fetchPosition");
  const collectFeesBtn = document.getElementById("collectFees");

  let provider, signer, userAddress;
  let poolContract, token0Addr, token1Addr, token0, token1;

  function log(...args){ logEl.textContent = new Date().toLocaleTimeString()+" | "+args.join(" ") + "\n" + logEl.textContent; }

  // connect to MetaMask
  connectBtn.onclick = async()=>{
    try{
      if(!window.ethereum) throw new Error("MetaMask não detectado");
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      provider = new ethers.BrowserProvider(window.ethereum, "any");
      const network = await provider.getNetwork();
      if(network.chainId !== CHAIN_ID) {
        log("Por favor, troque a rede para BSC (chainId 56) na MetaMask.");
      }
      signer = await provider.getSigner();
      userAddress = await signer.getAddress();
      document.getElementById("status").innerText = "Conectado: " + userAddress;
      poolContract = new ethers.Contract(POOL_ADDRESS, POOL_ABI, provider);
      log("Conectado. Endereço pool:", POOL_ADDRESS);
    }catch(e){ log("Erro connect:", e.message); }
  };

  // refresh pool info
  refreshBtn.onclick = async()=>{
    try{
      if(!poolContract) throw new Error("Conecte a wallet primeiro");
      token0Addr = await poolContract.token0();
      token1Addr = await poolContract.token1();
      token0 = new ethers.Contract(token0Addr, ERC20_ABI, provider);
      token1 = new ethers.Contract(token1Addr, ERC20_ABI, provider);
      const [sym0, sym1, decimals0, decimals1, slot0, tickSpacing, fee] = await Promise.all([
        token0.symbol(), token1.symbol(), token0.decimals(), token1.decimals(),
        poolContract.slot0(), poolContract.tickSpacing(), poolContract.fee()
      ]);
      poolInfoDiv.innerHTML = `
        <b>Pool:</b> ${POOL_ADDRESS} <br/>
        <b>Token0:</b> ${sym0} — ${token0Addr} (dec ${decimals0}) <br/>
        <b>Token1:</b> ${sym1} — ${token1Addr} (dec ${decimals1}) <br/>
        <b>tick (slot0):</b> ${slot0.tick} <br/>
        <b>tickSpacing:</b> ${tickSpacing} <br/>
        <b>fee (bps?):</b> ${fee} <br/>
        <small>Observação: esta pool é Pancake V3 CLMM (funções mint/collect/swaps).</small>
      `;
      log("Pool info atualizado.");
    }catch(e){ log("Erro refresh:", e.message); }
  };

  // approval: approve router to spend USDT
  approveUSDTBtn.onclick = async()=>{
    try{
      if(!signer) throw new Error("Conecte-se primeiro");
      if(!token0Addr) await refreshBtn.onclick();
      // determine which token is USDT (heurística: symbol contains 'USDT')
      const t0sym = await token0.symbol(); const t1sym = await token1.symbol();
      let usdtAddr = (t0sym && t0sym.toUpperCase().includes("USDT")) ? token0Addr : ((t1sym&&t1sym.toUpperCase().includes("USDT"))?token1Addr:null);
      if(!usdtAddr) { log("Não detectei USDT em token0/token1 da pool. Insira manualmente."); return; }
      const erc = new ethers.Contract(usdtAddr, ERC20_ABI, signer);
      const amount = ethers.parseUnits(document.getElementById("usdtAmount").value || "0", await erc.decimals());
      const tx = await erc.approve(ROUTER_V2, amount);
      log("Aprovação enviada. hash:", tx.hash);
      await tx.wait();
      log("Aprovação confirmada.");
    }catch(e){ log("Erro approve:", e.message); }
  };

  // swap metade USDT via Router V2 (exemplo simples)
  swapHalfBtn.onclick = async()=>{
    try{
      if(!signer) throw new Error("Conecte-se primeiro");
      // detect USDT address
      const t0sym = await token0.symbol(); const t1sym = await token1.symbol();
      let usdtAddr = (t0sym && t0sym.toUpperCase().includes("USDT")) ? token0Addr : ((t1sym&&t1sym.toUpperCase().includes("USDT"))?token1Addr:null);
      let otherAddr = (usdtAddr===token0Addr)?token1Addr:token0Addr;
      if(!usdtAddr){ log("USDT não detectado na pool."); return; }

      const amountInHuman = document.getElementById("usdtAmount").value || "0";
      const decimals = await (new ethers.Contract(usdtAddr, ERC20_ABI, provider)).decimals();
      const amountIn = ethers.parseUnits(amountInHuman, decimals);
      const amountHalf = amountIn / 2n;

      // Router v2 ABI minimal: swapExactTokensForTokens
      const ROUTER_V2_ABI = ["function swapExactTokensForTokens(uint256 amountIn,uint256 amountOutMin,address[] calldata path,address to,uint256 deadline) returns (uint256[] memory amounts)"];
      const router = new ethers.Contract(ROUTER_V2, ROUTER_V2_ABI, signer);

      // build path [USDT -> USDC] (order doesn't matter if pair exists)
      const path = [usdtAddr, otherAddr];
      const deadline = Math.floor(Date.now()/1000) + 60*300; // 5h

      // estimate amountOutMin = 0 for demo (DANGER: slippage) — em produção calcule via quoter
      const tx = await router.swapExactTokensForTokens(amountHalf, 0, path, userAddress, deadline, { gasLimit: 800000 });
      log("Swap enviado:", tx.hash);
      await tx.wait();
      log("Swap confirmado.");
    }catch(e){ log("Erro swap:", e.message); }
  };

  // helper: compute positions key = keccak256(owner,tickLower,tickUpper) to read positions mapping
  function makePositionKey(owner, tickLower, tickUpper){
    // per pool implementation positions mapping key is keccak256(abi.encodePacked(owner,tickLower,tickUpper))
    // ethers.js: keccak256(pack(...))
    const abiCoder = ethers.AbiCoder.defaultAbiCoder();
    const packed = ethers.concat([owner, ethers.hexZeroPad(ethers.hexlify(tickLower), 32), ethers.hexZeroPad(ethers.hexlify(tickUpper), 32)]);
    // simpler: use solidityKeccak256 via ethers 6 util
    const hash = ethers.keccak256(ethers.concat([owner, ethers.hexZeroPad(ethers.hexlify(tickLower), 32), ethers.hexZeroPad(ethers.hexlify(tickUpper), 32)]));
    return hash;
  }

  fetchPositionBtn.onclick = async()=>{
    try{
      if(!signer) throw new Error("conecte-se");
      const owner = userAddress;
      const tickLower = parseInt(document.getElementById("tickLower").value || "0");
      const tickUpper = parseInt(document.getElementById("tickUpper").value || "0");
      const key = makePositionKey(owner, tickLower, tickUpper);
      const pos = await poolContract.positions(key);
      log(`Position liquidity=${pos.liquidity} tokensOwed0=${pos.tokensOwed0} tokensOwed1=${pos.tokensOwed1}`);
      alert(`tokensOwed0: ${pos.tokensOwed0}\ntokensOwed1: ${pos.tokensOwed1}`);
    }catch(e){ log("Erro fetchPosition:", e.message); }
  };

  collectFeesBtn.onclick = async()=>{
    try{
      if(!signer) throw new Error("conecte-se");
      const recipient = userAddress;
      // amountRequested: set big values to collect all (uint128 max). We'll use max = 2**128-1
      const maxUint128 = (BigInt(1) << BigInt(128)) - BigInt(1);
      const poolWithSigner = poolContract.connect(signer);
      const tx = await poolWithSigner.collect(recipient, maxUint128, maxUint128, { gasLimit: 500000 });
      log("collect tx sent:", tx.hash);
      await tx.wait();
      log("collect confirmed.");
    }catch(e){ log("Erro collect:", e.message); }
  };

  // small helper para atualizar endereço quando account muda
  if(window.ethereum){
    window.ethereum.on && window.ethereum.on('accountsChanged', (accounts)=>{ if(accounts.length) { document.getElementById("status").innerText = "Conectado: "+accounts[0]; } });
  }

  // finally expose some vars to dev console
  window._demo = { POOL_ADDRESS, POOL_ABI, ROUTER_V2, SMART_ROUTER };
})();
</script>
</body>
</html>
